"Content"
"    (function ($) {&#xD;&#xA;	$.fn.countTo = function (options) {&#xD;&#xA;		options = options || {};&#xD;&#xA;		&#xD;&#xA;		return $(this).each(function () {&#xD;&#xA;			// set options for current element&#xD;&#xA;			var settings = $.extend({}, $.fn.countTo.defaults, {&#xD;&#xA;				from:            $(this).data('from'),&#xD;&#xA;				to:              $(this).data('to'),&#xD;&#xA;				speed:           $(this).data('speed'),&#xD;&#xA;				refreshInterval: $(this).data('refresh-interval'),&#xD;&#xA;				decimals:        $(this).data('decimals')&#xD;&#xA;			}, options);&#xD;&#xA;			&#xD;&#xA;			// how many times to update the value, and how much to increment the value on each update&#xD;&#xA;			var loops = Math.ceil(settings.speed / settings.refreshInterval),&#xD;&#xA;				increment = (settings.to - settings.from) / loops;&#xD;&#xA;			&#xD;&#xA;			// references & variables that will change with each update&#xD;&#xA;			var self = this,&#xD;&#xA;				$self = $(this),&#xD;&#xA;				loopCount = 0,&#xD;&#xA;				value = settings.from,&#xD;&#xA;				data = $self.data('countTo') || {};&#xD;&#xA;			&#xD;&#xA;			$self.data('countTo', data);&#xD;&#xA;			&#xD;&#xA;			// if an existing interval can be found, clear it first&#xD;&#xA;			if (data.interval) {&#xD;&#xA;				clearInterval(data.interval);&#xD;&#xA;			}&#xD;&#xA;			data.interval = setInterval(updateTimer, settings.refreshInterval);&#xD;&#xA;			&#xD;&#xA;			// initialize the element with the starting value&#xD;&#xA;			render(value);&#xD;&#xA;			&#xD;&#xA;			function updateTimer() {&#xD;&#xA;				value += increment;&#xD;&#xA;				loopCount++;&#xD;&#xA;				&#xD;&#xA;				render(value);&#xD;&#xA;				&#xD;&#xA;				if (typeof(settings.onUpdate) == 'function') {&#xD;&#xA;					settings.onUpdate.call(self, value);&#xD;&#xA;				}&#xD;&#xA;				&#xD;&#xA;				if (loopCount >= loops) {&#xD;&#xA;					// remove the interval&#xD;&#xA;					$self.removeData('countTo');&#xD;&#xA;					clearInterval(data.interval);&#xD;&#xA;					value = settings.to;&#xD;&#xA;					&#xD;&#xA;					if (typeof(settings.onComplete) == 'function') {&#xD;&#xA;						settings.onComplete.call(self, value);&#xD;&#xA;					}&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;			&#xD;&#xA;			function render(value) {&#xD;&#xA;				var formattedValue = settings.formatter.call(self, value, settings);&#xD;&#xA;				$self.html(formattedValue);&#xD;&#xA;			}&#xD;&#xA;		});&#xD;&#xA;	};&#xD;&#xA;	&#xD;&#xA;	$.fn.countTo.defaults = {&#xD;&#xA;		from: 0,               // the number the element should start at&#xD;&#xA;		to: 0,                 // the number the element should end at&#xD;&#xA;		speed: 1000,           // how long it should take to count between the target numbers&#xD;&#xA;		refreshInterval: 100,  // how often the element should be updated&#xD;&#xA;		decimals: 0,           // the number of decimal places to show&#xD;&#xA;		formatter: formatter,  // handler for formatting the value before rendering&#xD;&#xA;		onUpdate: null,        // callback method for every time the element is updated&#xD;&#xA;		onComplete: null       // callback method for when the element finishes updating&#xD;&#xA;	};&#xD;&#xA;	&#xD;&#xA;	function formatter(value, settings) {&#xD;&#xA;		return value.toFixed(settings.decimals);&#xD;&#xA;	}&#xD;&#xA;    }(jQuery));&#xD;&#xA;    jQuery(function ($) {&#xD;&#xA;      // custom formatting example&#xD;&#xA;      $('#count-number').data('countToOptions', {&#xD;&#xA;    	formatter: function (value, options) {&#xD;&#xA;    	  return value.toFixed(options.decimals).replace(/\B(?=(?:\d{3})+(?!\d))/g, ',');&#xD;&#xA;    	}&#xD;&#xA;      });&#xD;&#xA;      &#xD;&#xA;      // start all the timers&#xD;&#xA;      $('.timer').each(count);  &#xD;&#xA;      &#xD;&#xA;      function count(options) {&#xD;&#xA;    	var $this = $(this);&#xD;&#xA;    	options = $.extend({}, options || {}, $this.data('countToOptions') || {});&#xD;&#xA;    	$this.countTo(options);&#xD;&#xA;      }&#xD;&#xA;    });"
